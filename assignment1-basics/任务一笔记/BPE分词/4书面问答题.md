# **书面问答题 (Problem unicode1 & unicode2)**

## **任务1: Problem (unicode1): Understanding Unicode (理解Unicode)**

**英文问题原文及中文解析**

**(a) What Unicode character does `chr(0)` return?**

  * **中文解析**: `chr(0)` 这个函数会返回哪个Unicode字符？

**(b) How does this character's string representation (`__repr__()`) differ from its printed representation?**

  * **中文解析**: 这个字符的“字符串表示”（在交互式环境中直接回车显示的结果）和它的“打印表示”（用`print()`函数显示的结果）有什么不同？

**(c) What happens when this character occurs in text?**

  * **中文解析**: 当这个字符出现在文本中时，会发生什么？PDF建议你在Python解释器里亲自尝试下面的代码来观察现象：

    ```python
    >>> chr(0)
    >>> print(chr(0))
    >>> "this is a test" + chr(0) + "string"
    >>> print("this is a test" + chr(0) + "string")
    ```

**解答与分析**

**(a)** `chr(0)` 返回的是 **空字符 (Null character)**，通常写作 `\0`。

**(b)**

  * 它的**字符串表示** (`__repr__()`) 会显示为 `'\x00'`。这是一个明确的、给程序员看的表示，告诉你这是一个值为0的十六进制字节。

    注：上面这句话的详细解释

    **第一步：什么是“字节”？**

    我们之前讨论过，计算机最基础的存储单位是**字节 (Byte)**。一个字节的本质，就是一个可以表示 **0 到 255** 之间任意一个整数的“容器”。

    所以，当我们说“一个字节”时，我们脑海里想的其实就是一个**数字**，这个数字的范围是 0 到 255。

    ---

    **第二步：什么是“十六进制”？**

    “十六进制” (Hexadecimal) 只是一种**写数字的方式**，和我们平时用的“十进制”不一样。

    * **我们平时用的十进制 (Decimal)**：
      * 有 10 个符号：`0, 1, 2, 3, 4, 5, 6, 7, 8, 9`。
      * 规则是“逢十进一”。

    * **计算机爱用的十六进制 (Hexadecimal)**：
      * 有 16 个符号：`0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f`。（a代表10, b代表11, ... , f代表15）
      * 规则是“逢十六进一”。

    **同一个数字，可以用不同的进制来写**。就像“一”和“one”都表示同一个数量。

    我们来看几个例子：

    | 我们熟悉的十进制 | 对应的十六进制 |
    | :--------------- | :------------- |
    | 0                | 0              |
    | 9                | 9              |
    | 10               | a              |
    | 15               | f              |
    | 16               | 10             |
    | 255              | ff             |

    ---

    **第三步：把它们连起来理解**

    现在我们把“字节”和“十六进制”连起来。

    * 我们知道，“一个字节”就是一个 **0 到 255 的数字**。
    * 我们也知道，“十六进制”是一种**写数字的方式**。

    所以，“**一个值为0的十六进制字节**”这句话，其实是在说：

    **有一个字节，它代表的数字是 0。我们选择用十六进制的方式来写这个数字 0。**

    * 数字 `0` 的十进制写法是 `0`。
    * 数字 `0` 的十六进制写法也是 `0`。

    这句话听起来有点绕，但本质上就是用一种更专业的说法来描述数字 **0**。

    ---

    **最后，`'\x00'` 这个表示法是什么意思？**

    在很多编程语言（包括Python）里，当需要在字符串中表示一个无法直接打印的特殊字符或字节时，会使用一种叫做**“转义序列”**的表示法。

    `'\x00'` 就是这种表示法，专门用来表示十六进制的字节。我们来拆解它：

    * **`\`**: 这是一个“转义符”，它告诉程序：“跟在我后面的字符有特殊含义，不要把它当成普通字符处理。”
    * **`x`**: `x` 紧跟在 `\` 后面，专门用来表示“**接下来是一个十六进制的数字**”。
    * **`00`**: 这就是那个十六进制的数字本身。一个字节通常用两位十六进制数来表示（从 `00` 到 `ff`），所以即使是 `0`，也习惯写成 `00`。

    **所以，`'\x00'` 这整个符号，就是一个给程序员看的、明确无误的写法，它的意思就是：“这里有一个字节，它的数值是十六进制的00，也就是十进制的0。”** 这就是 `chr(0)` 这个空字符在代码中的“身份证”。

  * 它的**打印表示** (`print()`) 通常是**不可见的**。它在屏幕上不占据任何空间，你看不到任何东西。

**(c)**

  * 当这个空字符出现在文本中时，很多程序（包括一些终端）会把它**解释为字符串的结束标记**。
  * 因此，当你运行 `print("this is a test" + chr(0) + "string")` 时，`print` 函数在遇到 `chr(0)` 时可能就会认为字符串已经结束了，所以**只会打印出 "this is a test"**，而后面的 "string" 则被忽略了。

-----

## **任务2: Problem (unicode2): Unicode Encodings (Unicode编码)**

**英文问题原文及中文解析**

**(a) What are some reasons to prefer training our tokenizer on UTF-8 encoded bytes, rather than UTF-16 or UTF-32?**

  * **中文解析**: 相比于UTF-16或UTF-32，我们为什么更倾向于选择在UTF-8编码的字节上训练我们的分词器？

**(b) Consider the following (incorrect) function... Why is this function incorrect? Provide an example...**

  * **中文解析**: 看看下面这个**错误**的函数。它为什么是错的？请提供一个会导致它出错的输入例子。

    ```python
    def decode_utf8_bytes_to_str_wrong(bytestring: bytes):
        return "".join([bytes([b]).decode("utf-8") for b in bytestring])
    ```

     注：关于上面代码的详细解释：

    **代码: `def decode_utf8_bytes_to_str_wrong(bytestring: bytes):`**

    **1. 整体代码实现的作用**

    这行代码的整体作用是**定义一个函数**。这个函数名为 `decode_utf8_bytes_to_str_wrong`，它被设计用来接收一个名为 `bytestring` 的参数，并期望这个参数的类型是 `bytes`。

    **2. 逐行代码实现的作用**

    * **当前行代码**: `def decode_utf8_bytes_to_str_wrong(bytestring: bytes):`
    * **该行作用**: 声明一个函数的开始，包括它的名称、参数和参数的类型提示。

    **3. 涉及的语法点**

    * **`def`**: Python中用于**定义函数**的关键字。它告诉解释器：“接下来我要创建一个新的函数了。”
    * **`decode_utf8_bytes_to_str_wrong`**: 这是函数的**名称**。
    * **`( ... )`**: 括号内是函数的**参数列表**。
    * **`bytestring: bytes`**: 这是函数的参数。
      * `bytestring`: 参数的**名称**。
      * `: bytes`: 这是一个**类型提示 (Type Hint)**，它告诉阅读代码的人（以及代码编辑器），我们期望传入这个函数的 `bytestring` 参数应该是一个 `bytes` 对象。
    * **`:`**: 冒号标志着函数头部定义的结束，接下来的缩进代码块是函数的主体。

    ---

    **代码: `return "".join([bytes([b]).decode("utf-8") for b in bytestring])`**

    **1. 整体代码实现的作用**

    这行代码是函数的主体和返回部分。它的整体作用是：遍历输入的 `bytestring` 中的每一个字节，尝试将**每一个单独的字节**解码成一个字符，然后将所有解码出的单个字符拼接成一个最终的字符串并返回。

    **2. 逐行代码实现的作用**

    * **当前行代码**: `return "".join(...)`
    * **该行作用**: 执行一个列表推导式来处理字节，然后用 `join` 方法将结果拼接成字符串，并最终通过 `return` 关键字将结果作为函数的输出返回。

    **3. 涉及的语法点 (从内到外拆解)**

    这是一个“列表推导式”和字符串方法的组合，我们把它拆成几个核心部分来理解：

    1. **`[ ... for b in bytestring]`**: 这是**列表推导式 (List Comprehension)** 的基本结构。

       * **`for b in bytestring`**: 这是推导式的**循环部分**。它会遍历输入的 `bytestring` 对象。因为 `bytestring` 是一个字节序列，所以在每次循环中，变量 `b` 会被依次赋值为序列中的每一个字节的整数值（例如，`b` 第一次是 `228`，第二次是 `189`，等等）。
       * **`...` (循环体部分)**: `for` 循环前面的表达式 `bytes([b]).decode("utf-8")` 是每次循环要执行的操作。

    2. **`bytes([b])`**:

       * **作用**: 将单个整数 `b` 重新包装成一个只包含一个字节的 `bytes` 对象。

       * **讲解**:

         * `b`: 当前循环得到的单个字节的整数值（如 `228`）。
         * `[b]`: 将这个整数放入一个列表中，得到 `[228]`。
         * `bytes(...)`: `bytes()` 构造函数接收这个列表，创建一个只含一个字节的 `bytes` 对象，即 `b'\xe4'`。

       * 补充讲解：

         详细解释一下为什么不能直接用 `bytes(97)` 来得到 `b'a'`。

         ---

         **`bytes()` 构造函数的“双重身份”**

         问题的根源在于，`bytes()` 这个函数被设计成了可以接受**多种不同类型**的输入，并且根据输入类型的不同，它的行为也完全不同。我们来看它最常见的两种用法：

         **用法一：`bytes(整数)`**

         当你给 `bytes()` 函数传递一个**单个整数**时，它的作用是**创建一个指定长度的、内容全部为零的 `bytes` 对象**。

         * **`bytes(5)`**
           * **作用**: 创建一个长度为 5 的、由零填充的 `bytes` 对象。
           * **结果**: `b'\x00\x00\x00\x00\x00'`

         * **`bytes(97)`**
           * **作用**: 创建一个长度为 97 的、由零填充的 `bytes` 对象。
           * **结果**: 一个包含 97 个 `\x00` 的 `bytes` 对象。

         这是 `bytes()` 的一种功能，用于预先分配一块内存空间。

         **用法二：`bytes(可迭代对象)`**

         当你给 `bytes()` 函数传递一个**可迭代对象**（比如列表 `list`、元组 `tuple`）时，它的作用是**将这个可迭代对象中的每一个整数元素，作为字节值，来创建一个新的 `bytes` 对象**。

         * **`bytes([99, 97, 116])`**
           * **作用**: 遍历列表 `[99, 97, 116]`，取出每个整数，用它们来构建 `bytes` 对象。
           * **结果**: `b'cat'`

         * **`bytes([97])`**
           * **作用**: 遍历列表 `[97]`，取出整数 `97`，用它来构建 `bytes` 对象。
           * **结果**: `b'a'`

         ---

         **为什么必须这样设计？—— 为了消除歧义**

         现在，问题的答案就浮出水面了。请设想一下，如果Python的设计者允许 `bytes(97)` 直接得到 `b'a'`，会发生什么？

         **这时，`bytes(97)` 这个调用就产生了无法解决的歧义：**

         * **解释A**: 用户是想创建一个**长度为97**的、零填充的 `bytes` 对象吗？ (用法一)
         * **解释B**: 用户是想创建一个**内容为 `b'a'`** (其整数值为97) 的 `bytes` 对象吗？ (您期望的用法)

         程序无法读懂你的心思，它不知道你想要哪种结果。

         为了解决这个歧义，Python的设计者遵循了Python之禅中的一条重要原则：**“Explicit is better than implicit.” (明确优于含蓄)**。

         他们做出了一个清晰的规定：

         * 如果你想**指定长度**，就直接传一个**整数**。
         * 如果你想**指定内容**，就必须传一个**可迭代对象**（比如列表），即使这个可迭代对象里只有一个元素。

         所以，`bytes([97])` 这种写法，虽然看起来多打了一个方括号，但它是在**明确地、毫无歧义地**告诉Python：“我想要的是一个**内容**由整数 `97` 构成的 `bytes` 对象，而不是一个**长度**为97的 `bytes` 对象。”

         **总结：**
         这个看似“麻烦”的设计，正是为了保证代码的清晰性和可预测性，避免程序员因为一个有歧义的函数调用而写出难以察觉的bug。虽然写起来多了一步，但它让你的意图变得无比清晰。

    3. **`.decode("utf-8")`**:

       * **作用**: 对上一步生成的、只含单个字节的 `bytes` 对象，尝试使用 `"utf-8"` 规则进行解码，将其转换成一个字符串。
       * **讲解**:
         * `.decode()`: 这是 `bytes` 对象的方法，用于将其转换回 `str` 类型。
         * `"utf-8"`: 指定解码时使用的规则。
         * **（这就是逻辑错误点）**: 对于像 `b'\xe4'` 这样的字节，它本身并不是一个完整的UTF-8字符，所以在这里解码会直接失败并抛出 `UnicodeDecodeError` 异常。只有当字节本身就是一个完整的字符时（如 `b'a'`），这一步才能成功。

    4. **`"".join(...)`**:

       * **作用**: 将列表推导式生成的所有单个字符串，用一个“空字符串”作为连接符，拼接成一个最终的、完整的字符串。
       * **讲解**:
         * `"..."`: 这是一个字符串对象，在这里是空字符串 `""`，表示拼接时中间不加任何东西。
         * `.join()`: 这是字符串的方法，它接收一个包含字符串的列表作为参数。
         * **例子**: 如果列表推导式（假设它能成功）生成了 `['h', 'e', 'l', 'l', 'o']`，那么 `"".join(['h', 'e', 'l', 'l', 'o'])` 的结果就是 `"hello"`。

    5. **`return`**:

       * **作用**: Python的关键字，用于结束函数的执行，并将紧跟其后的表达式的值作为函数的输出返回。在这里，它返回 `"".join()` 的最终结果。

**(c) Give a two byte sequence that does not decode to any Unicode character(s).**

  * **中文解析**: 请给出一个由两个字节组成的序列，这个序列无法被解码成任何有效的Unicode字符。

**解答与分析**

**(a)** 选择UTF-8的主要原因有：

  * **空间效率**: 对于以英文为主的文本，UTF-8使用单个字节表示一个字符，与ASCII完全兼容，非常节省空间。而UTF-16至少用2个字节，UTF-32则固定用4个字节，会造成很大浪费。
  * **普遍性**: UTF-8是互联网上最主流的编码标准（超过98%的网页使用它）。使用它能确保我们的分词器与绝大多数数据源兼容。
  * **无字节顺序标记问题**: UTF-16和UTF-32有字节顺序（大端/小端）的问题，有时需要在文件开头添加特殊标记（BOM）来区分，而UTF-8没有这个问题。

**(b)**

  * **为什么是错的**: 这个函数错误地假设了UTF-8编码中的**每一个字节都可以独立地解码成一个字符**。但事实是，对于多字节字符（如中文、表情符号），必须把**多个字节组合在一起**才能正确解码。这个函数粗暴地将它们拆开，逐个字节进行解码，必然会失败。

  * **出错的例子**: 任何表示多字节字符的`bytes`对象都可以。例如：

    ```python
    # "你" 的UTF-8编码是 b'\xe4\xbd\xa0'
    error_example = "你".encode("utf-8") 
    
    # 运行错误的函数会直接抛出 UnicodeDecodeError 异常
    # 因为单个字节 \xe4 并不是一个合法的UTF-8字符开头
    decode_utf8_bytes_to_str_wrong(error_example) 
    ```

**(c)**

  * **例子**: `b'\xc0\x80'`
  * **解释**: 在UTF-8编码规则中，字节序列的第一个字节决定了这是一个多长字符的开头。有很多字节组合是**不合法、不允许出现**的。例如，`\xc0` 和 `\xc1` 就被明确规定为无效的起始字节，所以任何以它们开头的字节序列都无法被正确解码。