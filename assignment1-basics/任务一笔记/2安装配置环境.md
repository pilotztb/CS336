# 安装配置环境一

## 安装 uv 工具

课程官方在PDF中推荐使用 uv 工具来管理环境和运行测试。这是一个非常新的、速度极快的Python包管理器。在服务器终端中运行以下命令来安装它：

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

**注意**：安装后，可能需要重启终端或根据提示运行 `source` 命令才能使 `uv` 命令生效。

## 创建并激活虚拟环境

首先，请确保你的终端位于你上传的 `assignment1-basics-main` 这个文件夹内。然后执行：

```bash
# 使用 uv 创建一个名为 .venv 的虚拟环境
uv venv

# 激活这个环境
source .venv/bin/activate
```

激活成功后，终端提示符前应该会出现 `(.venv)` 的字样。

## 安装所有项目依赖

现在，运行以下命令来安装所有必需的库（如 torch, numpy, pytest 等）。uv 会自动读取 `pyproject.toml` 文件来确定需要安装什么。

```bash
uv pip install -e .
```

`-e .` 参数会以“可编辑模式”安装当前项目，这是标准的开发实践。

# 安装配置环境二

好的，这是一篇根据我们完整的交互过程整理的技术博客。它涵盖了从最初的 Python 版本冲突到最后的 Rust 编译器问题的整个调试过程。

-----

## 博客文章：Python 环境配置实战：从 PyTorch 版本冲突到 Rust 编译失败

### 简介

你是否遇到过这样的情况：满怀信心地从 GitHub 克隆了一个新的 Python 项目，在你的新电脑或 Docker 容器里准备大干一场。你熟练地创建了一个虚拟环境，运行了 `pip install -e .`（或者 `uv pip install -e .`），然后……屏幕上瞬间刷满了红色的错误信息。

欢迎来到 Python 依赖管理的奇妙世界。

这篇文章将复现一个真实且非常普遍的调试过程。我们将从一个看似简单的 PyTorch 版本冲突开始，一步步解决“环境嵌套”的陷阱，并最终面对一个意想不到的“拦路虎”——一个需要 Rust 编译器的依赖包。

### 第 1 幕：最初的失败 - "Python 版本太新"

我们从项目目录开始，运行安装命令：

```bash
# (assignment-env) user@host:~/my_project# uv pip install -e .
```

很快，我们收到了第一个错误：

```
× No solution found when resolving dependencies:
╰─▶ Because torch==2.6.0 has no wheels with a
    matching Python ABI tag (e.g., `cp314`) ...
    ...
    hint: You require CPython 3.14 (`cp314`), but we only found
    wheels for `torch` (v2.6.0) with the following Python ABI tags:
    `cp39`, `cp310`, `cp311`, `cp312`, `cp313`
```

**问题分析：**
这是最经典的依赖冲突。

1.  **你的环境**: `You require CPython 3.14 (cp314)`。我们的环境是 **Python 3.14**。
2.  **项目需求**: `torch==2.6.0`。项目（在 `pyproject.toml` 或 `setup.py` 中）指定了它需要 PyTorch 2.6.0 版本。
3.  **冲突点**: PyTorch 2.6.0 的官方预编译包（"wheels"）**不支持** Python 3.14。错误信息明确告诉我们，它只支持到 Python 3.13 (`cp313`)。

**解决方案：**
我们不能使用 Python 3.14。我们需要创建一个**使用 PyTorch 2.6.0 支持的 Python 版本**的新环境。

根据错误提示，Python 3.13 (`cp313`) 是受支持的最新版本。我们来创建一个新的 Conda 环境。

```bash
# 1. 退出当前环境
(assignment-env) user@host:~$ conda deactivate
(base) user@host:~$

# 2. 创建一个使用 Python 3.13 的新环境
(base) user@host:~$ conda create -n project-py313 python=3.13

# 3. 激活新环境
(base) user@host:~$ conda activate project-py313
(project-py313) user@host:~$
```

-----

### 第 2 幕：诡异的重现 - “为什么还是 Python 3.14？”

我们激活了新的 `project-py313` 环境，信心满满地再次尝试安装：

```bash
(project-py313) user@host:~$ cd ~/my_project
(project-py313) user@host:~/my_project# source .venv/bin/activate
(.venv) (project-py313) user@host:~/my_project# uv pip install -e .
```

结果，我们收到了**和第一幕一模一样的错误**！

```
× No solution found when resolving dependencies:
...
hint: You require CPython 3.14 (`cp314`)...
```

**问题分析：**
为什么 `uv` 仍然认为我们在使用 Python 3.14？

关键在于我们的终端提示符：`(.venv) (project-py313) user@host:...`

这表明我们**同时激活了两个环境**！

1.  我们首先激活了 Conda 环境 `project-py313` (它有 Python 3.13)。
2.  然后，我们又运行了 `source .venv/bin/activate`，激活了项目目录中一个**已存在的**虚拟环境 `.venv`。
3.  这个 `.venv` 很可能是我们**最初**在 Python 3.14 环境下创建的，它“覆盖”了我们的 Conda 环境，导致系统 Python 版本又变回了 3.14。

**解决方案：**
我们不需要这个 `.venv`。Conda 环境本身就是我们的隔离环境。

```bash
# 1. 退出所有嵌套的环境，直到回到 base
(.venv) (project-py313) user@host:~$ deactivate
(project-py313) user@host:~$ deactivate
(base) user@host:~$

# 2. 只激活正确的 Conda 环境
(base) user@host:~$ conda activate project-py313
(project-py313) user@host:~$

# 3. 进入项目目录，并删除那个会引起混淆的 .venv
(project-py313) user@host:~$ cd ~/my_project
(project-py313) user@host:~/my_project# rm -rf .venv

# 4. 再次尝试安装 (这次不要激活 .venv)
(project-py313) user@host:~/my_project# uv pip install -e .
```

-----

### 第 3 幕：新的敌人 - "找不到 Rust 编译器"

PyTorch 的错误消失了！`uv` 成功解析了 `torch`。但我们又遇到了一个新问题：

```
× Failed to build `tiktoken==0.12.0`
├─▶ The build backend returned an error
╰─▶ Call to `setuptools.build_meta.build_wheel` failed (exit status: 1)
...
    running build_ext
    running build_rust
...
    error: can't find Rust compiler
```

**问题分析：**
这是一个全新的问题。

1.  项目依赖另一个包 `tiktoken` (一个 OpenAI 的 BPE 分词器)。
2.  `uv` 找不到一个为我们当前环境 (Python 3.13 + Linux) 预编译好的 `tiktoken` wheel。
3.  因此，`uv` 尝试从**源代码**编译 `tiktoken`。
4.  错误日志中的 `running build_rust` 告诉我们，这个包不是用 C 写的，而是用 **Rust** 写的。
5.  `error: can't find Rust compiler` 表明我们的系统里没有安装 Rust 编译工具链。

**（旁注：为什么 Python 3.12 也不行？）**
我们可能以为降级到 Python 3.12 (`cp312`) 就能找到 `tiktoken` 的预编译包。但经过尝试，我们发现对于我们这个特定的 Linux 平台，`tiktoken 0.12.0` 同样没有提供 Python 3.12 的 wheel，所以问题依旧。

**解决方案：**
既然必须编译，我们就给它提供编译器。我们可以在 Conda 环境中直接安装 Rust。

```bash
# 1. 确保我们还在正确的环境中 (project-py313 或 project-py312)
(project-py313) user@host:~/my_project#

# 2. 使用 conda-forge 安装 Rust
(project-py313) user@host:~/my_project# conda install -c conda-forge rust

# (等待 Rust 工具链安装完成...)

# 3. 再次运行安装命令
(project-py313) user@host:~/my_project# uv pip install -e .
```

### 最终幕：成功

这一次，`uv` 在尝试构建 `tiktoken` 时，成功找到了 Rust 编译器。编译过程可能需要几分钟，但它不再报错。

```
Using Python 3.13.5 environment at: ...
Resolved 61 packages in 1.36s
...
(Building tiktoken...)
...
Successfully installed ...
```

环境终于配置成功！

### 结语与教训

这次调试之旅为我们提供了几个宝贵的教训：

1.  **仔细阅读错误提示**：`cp314` 和 `cp313` 这样的标签是关键线索，它们直接指向 Python 版本不兼容。
2.  **警惕“环境嵌套”**：`conda activate` 和 `source .venv/bin/activate` 混用是常见的陷阱。请确保你始终只在一个你期望的环境中工作。
3.  **Python 包可能依赖其他语言**：`error: can't find Rust compiler` (或 `gcc` / `cmake`) 是一个明确信号，说明你需要安装 Python 之外的系统级构建工具。
4.  **Conda 是你的好帮手**：使用 Conda，你不仅可以管理 Python 版本 (`python=3.13`)，还可以轻松安装非 Python 的依赖，如 `conda install rust`，从而保持环境的整洁。